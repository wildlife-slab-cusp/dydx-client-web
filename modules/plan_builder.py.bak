# plan_builder.py - updated 2025-08-09

import os
import math
import psycopg2
import sqlite3


def select_plan_cfg():
    """Select config from Neon Postgres plan_cfg table."""
    db_url = os.environ.get("DATABASE_URL")
    if not db_url:
        raise RuntimeError("DATABASE_URL not set")

    conn = psycopg2.connect(db_url)
    cur = conn.cursor()
    cur.execute("SELECT * FROM plan_cfg")
    row = cur.fetchone()
    keys = [desc[0] for desc in cur.description]
    cfg = dict(zip(keys, row))

    cur.close()
    conn.close()
    return cfg


def extract_plan_values(subaccount, filled_order, position):
    """Extract plan values from dydx data."""

    sub = subaccount
    ord = filled_order
    pos = position

    data = {
        "filled_price": filled_order["price"],
        "position_size": position["size"],
        "equity": subaccount["equity"],
        "net_funding": position["netFunding"],
        "realized_pnl": position["realizedPnl"],
        "unrealized_pnl": position["unrealizedPnl"],
        "entry_price": position["entryPrice"],
        "exit_price": position["exitPrice"],
        "sum_open": position["sumOpen"],
        "sum_close": position["sumClose"],
    }

    return data


def build_order_plan(data, cfg, side):
    """Build order plan for 'buy' or 'sell' side."""
    import math
    plan = []

    accum_size  = cfg["current_accumulation"]
    leverage_max = cfg["leverage_max"]
    leverage_min = cfg["leverage_min"]

    if side == "buy":
        order_size = cfg["buy_order_size"]
        delta      = cfg["buy_price_delta"]
        count      = cfg["buy_orders_max_qty"]

        price      = math.floor(
            (data["filled_price"] - delta) / 1000
        ) * 1000 + 500
        pos_size   = data["position_size"] + order_size
        entry_sum  = data["sum_open"] + order_size
        entry_price = (
            data["entry_price"] * data["sum_open"]
            + order_size * price
        ) / entry_sum
        exit_sum   = data["sum_close"]
        exit_price = data["exit_price"]

    elif side == "sell":
        order_size = cfg["sell_order_size"]
        delta      = cfg["sell_price_delta"]
        count      = cfg["sell_orders_max_qty"]

        price      = math.floor(
            (data["filled_price"] + delta) / 1000
        ) * 1000 + 500
        pos_size   = data["position_size"] - order_size
        entry_sum  = data["sum_open"]
        entry_price = data["entry_price"]
        exit_sum   = data["sum_close"] + order_size
        exit_price = (
            data["exit_price"] * data["sum_close"]
            + order_size * price
        ) / exit_sum

    else:
        raise ValueError(f"Invalid side: {side}")

    for i in range(count):
        if i > 0:
            if side == "buy":
                price      -= delta
                pos_size   += order_size
                entry_sum  += order_size
                entry_price = (
                    entry_price * (entry_sum - order_size)
                    + order_size * price
                ) / entry_sum
            else:
                price      += delta
                pos_size   -= order_size
                exit_sum   += order_size
                exit_price = (
                    exit_price * (exit_sum - order_size)
                    + order_size * price
                ) / exit_sum

        if side == "buy":
            unreal   = (price - entry_price) * pos_size
            realized = (
                (exit_price - entry_price) * exit_sum
                + data["net_funding"]
            )
        else:
            unreal   = (price - entry_price) * pos_size
            realized = (
                (exit_price - entry_price) * exit_sum
                + data["net_funding"]
            )

        total = unreal + realized

        if i == 0:
            equity = (
                data["equity"] - data["unrealized_pnl"]
                - data["realized_pnl"] + total
            )
        else:
            equity = equity - prev_total + total

        lev      = round((pos_size * price) / equity, 2)
        pos_size = round(pos_size, 4)

        if side == "buy":
            include = lev <= leverage_max
        else:
            include = lev >= leverage_min

        plan.append({
            "side": side,
            "orderPrice": round(price, 2),
            "orderSize": order_size,
            "positionSize": round(pos_size, 4),
            "entrySum": round(entry_sum, 4),
            "entryPrice": round(entry_price, 2),
            "exitSum": round(exit_sum, 6),
            "exitPrice": round(exit_price, 2),
            "fundingPmt": data["net_funding"],
            "realizedPnL": round(realized, 2),
            "unrealizedPnL": round(unreal, 2),
            "totalPnL": round(total, 2),
            "equityLeverage": lev,
            "includeFlag": include
        })

        prev_total = total

        # Sort by orderPrice descending
        plan.sort(key=lambda x: x["orderPrice"], reverse=True)

    return plan
